// compomentsController.js

const db = require('../db');

exports.getAllComponents = async (req, res) => {
  try {
    const { rows } = await db.query('SELECT * FROM components ORDER BY created_at');
    res.json(rows);
  } catch (err) {
    res.status(500).json({ error: 'Database error' });
  }
};

exports.getComponentById = async (req, res) => {
  try {
    const { rows } = await db.query('SELECT * FROM components WHERE id = $1', [req.params.id]);
    if (!rows.length) return res.status(404).json({ error: 'Component not found' });
    res.json(rows[0]);
  } catch (err) {
    res.status(500).json({ error: 'Database error' });
  }
};

exports.createComponent = async (req, res) => {
  try {
    const {
      machine_id, name, description, status, serial_number, manufacturer,
      replacement_cycle_hours, last_checkup_date, next_checkup_date, notes
    } = req.body;
    if (!machine_id) return res.status(400).json({ error: 'Valid machine_id is required.' });
    if (!name) return res.status(400).json({ error: 'Component name is required.' });

    // Make sure the machine exists (optional but good practice)
    const checkMachine = await db.query('SELECT 1 FROM machines WHERE id = $1', [machine_id]);
    if (!checkMachine.rowCount) return res.status(400).json({ error: 'machine_id does not exist.' });

    // Note: id will be auto-generated by Postgres
    const sql = `
      INSERT INTO components
        (machine_id, name, description, status, serial_number, manufacturer, replacement_cycle_hours, last_checkup_date, next_checkup_date, notes)
      VALUES
        ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      RETURNING *`;
    const values = [machine_id, name, description, status || 'OK', serial_number, manufacturer, replacement_cycle_hours, last_checkup_date, next_checkup_date, notes];

    const { rows } = await db.query(sql, values);
    res.status(201).json(rows[0]);
  } catch (err) {
    res.status(500).json({ error: 'Database error adding component' });
  }
};

// PATCH: Partial update for a component (user-editable fields only)
exports.patchComponent = async (req, res) => {
  // Only allow these fields to be patched by the frontend:
  const allowed = [
    "name", "description", "status", "serial_number", "manufacturer",
    "replacement_cycle_hours", "last_checkup_date", "next_checkup_date", "notes"
  ];

  const set = [];
  const values = [];
  let idx = 1;

  for (const key of allowed) {
    if (req.body[key] !== undefined) {
      set.push(`${key} = $${idx++}`);
      values.push(req.body[key]);
    }
  }

  if (!set.length) {
    return res.status(400).json({ error: "No valid fields to update" });
  }

  values.push(req.params.id); // for WHERE clause

  try {
    const sql = `
      UPDATE components
      SET ${set.join(', ')}
      WHERE id = $${values.length}
      RETURNING *`;
    const { rows } = await db.query(sql, values);
    if (!rows.length) return res.status(404).json({ error: 'Component not found' });
    res.json(rows[0]);
  } catch (err) {
    res.status(500).json({ error: 'Database error (patch)', details: err.message });
  }
};

exports.deleteComponent = async (req, res) => {
  try {
    await db.query('DELETE FROM components WHERE id=$1', [req.params.id]);
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ error: 'Database error deleting component' });
  }
};

exports.getSensorsForComponent = async (req, res) => {
  try {
    const { rows } = await db.query('SELECT * FROM sensors WHERE component_id=$1', [req.params.id]);
    res.json(rows);
  } catch (err) {
    res.status(500).json({ error: 'Database error fetching sensors' });
  }
};